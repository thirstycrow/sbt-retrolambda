package sbtretrolambda

import java.io._
import sbt.Keys._
import sbt._
import sbt.plugins.JvmPlugin
import scala.collection.mutable

object SbtRetrolambda extends AutoPlugin {

  object autoImport {

    val RetrolambdaConfig = config("retrolambda").hide

    val retrolambdaVersion = settingKey[String]("Retrolambda version to use.")

    val retrolambdaBytecodeVersion = settingKey[Int]("Major version number for the generated bytecode.")

    val retrolambdaDefaultMethods = settingKey[Boolean]("Whether to backport default methods and static methods on interfaces.")

    val retrolambdaInputDir = taskKey[File]("Input directory from where the original class files are read.")

    val retrolambdaOutputDir = taskKey[File]("Output directory into where the generated class files are written.")

    val retrolambdaClasspath = taskKey[Seq[File]]("Classpath containing the original class files and their dependencies.")

    val retrolambdaIncludedFiles = taskKey[Option[Seq[File]]]("List of files to process, instead of processing all files.")

    val retrolambdaQuiet = settingKey[Boolean]("Reduces the amount of logging.")

    val retrolambdaDependency = settingKey[Option[File]]("Path to the retrolambda jar.")

    val retrolambda = taskKey[Unit]("Retrolambda takes Java 8 classes and backports lambda expressions and some other language features to work on Java 7, 6 or 5.")
  }

  override def requires = JvmPlugin

  import autoImport._

  override def projectConfigurations: Seq[Configuration] = Seq(RetrolambdaConfig)

  override def projectSettings: Seq[Def.Setting[_]] =
    inConfig(RetrolambdaConfig)(defaultRetrolambdaSettings) ++ retrolambdaDependencySettings

  def printToTempFile(lines: Seq[String]): File = {
    val file = File.createTempFile("sbt-retrolambda", "classpath")
    val fileWriter = new PrintWriter(file, "UTF-8")
    try {
      lines.foreach(fileWriter.println)
      file
    } finally {
      fileWriter.close()
    }
  }

  def defaultRetrolambdaSettings = Seq(
    retrolambdaVersion := "2.5.3",
    retrolambdaBytecodeVersion := 51,
    retrolambdaDefaultMethods := true,
    retrolambdaInputDir := (classDirectory in Compile).value,
    retrolambdaOutputDir := (target in Compile).value / "retrolambda-classes",
    retrolambdaClasspath := (classDirectory in Compile).value +: (dependencyClasspath in Compile).value.map(_.data),
    retrolambdaIncludedFiles := None,
    retrolambdaQuiet := false,
    retrolambda := runRetrolambda.dependsOn(compile in Compile).value
  )

  def retrolambdaDependencySettings = Seq(
    ivyConfigurations += RetrolambdaConfig,
    libraryDependencies += {
      val version = (retrolambdaVersion in RetrolambdaConfig).value
      "net.orfjackal.retrolambda" % "retrolambda" % version % RetrolambdaConfig
    },
    exportJars := true,
    mappings in packageBin in Compile := Def.task {
      val outputDir = (retrolambdaOutputDir in RetrolambdaConfig).value
      (mappings in packageBin in Compile).value.filterNot(_._2.endsWith(".class")) ++
          (outputDir ** "*.class").pair(Path.relativeTo(outputDir))
    }.value,
    copyResources in Compile := (copyResources in Compile).dependsOn(retrolambda in RetrolambdaConfig).value
  )

  def runRetrolambda = Def.task {
    val jvmOptions = mutable.Buffer(
      s"-Dretrolambda.bytecodeVersion=${retrolambdaBytecodeVersion.value}",
      s"-Dretrolambda.defaultMethods=${retrolambdaDefaultMethods.value}",
      s"-Dretrolambda.inputDir=${retrolambdaInputDir.value.getAbsolutePath}",
      s"-Dretrolambda.outputDir=${retrolambdaOutputDir.value.getAbsolutePath}",
      s"-Dretrolambda.classpath=${retrolambdaClasspath.value.map(_.getAbsolutePath).mkString(File.pathSeparator)}",
      s"-Dretrolambda.quiet=${retrolambdaQuiet.value}"
    )
    retrolambdaIncludedFiles.value.foreach(includedFiles =>
      jvmOptions.append(s"-Dretrolambda.includedFiles=${includedFiles.map(_.getAbsolutePath).mkString(File.pathSeparator)}")
    )
    jvmOptions.append("-jar")
    jvmOptions.append(getRetrolambda.value.get.getAbsolutePath)
    Fork.java(ForkOptions().withRunJVMOptions(jvmOptions.toVector), Nil) match {
      case 0 => // OK
      case c => throw new IllegalStateException(s"Retrolambda failed with exit code ${c}")
    }
  }

  def getRetrolambda = Def.task {
    update.value.matching {
      moduleFilter(organization = "net.orfjackal.retrolambda", name = "retrolambda") && artifactFilter(`type` = "jar")
    }.headOption
  }
}
